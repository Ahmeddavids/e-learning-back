// filepath: /Users/isaac/e-learning-back/src/core/controllers/user.ts
import bcrypt from 'bcrypt';
import BadRequestError from '../errors/BadRequestError';
import ResourceNotFoundError from '../errors/ResourceNotFoundError';
import { capitalizeFirstLetter } from '../helpers/utilities';
import { IUser } from '../interfaces/user';
import UserService from '../services/user';
import { VerificationTokenStatus } from '../constants/user';
import EmailService from '../services/email';
import { logger } from '../utils/logger';
import settings from '../config/application';
import { generateAccessJwtToken, generateRefreshJwtToken } from '../helpers/auth';

// Define interfaces needed for the controller
interface LoginResponse {
  firstname: string;
  lastname: string;
  email: string;
  accessToken: string;
  refreshToken: string;
}

interface UserProfileData {
  id: string;
  firstname: string;
  lastname: string;
  email: string;
  phone: string;
  gender: string;
  role?: string;
  isEmailVerified: boolean;
}

interface ResendVerificationEmailResponse {
  email: string;
  nextResendDuration: number;
}

class UserController {
  private userService: UserService;

  constructor(_userService: UserService) {
    this.userService = _userService;
  }

  async registerUser(body: Omit<IUser, '_id' | 'isEmailVerified'>): Promise<Partial<IUser> | ResendVerificationEmailResponse> {
    const user = await this.userService.getUser({ email: body.email });
    if (user) {
      const response = await this.resendVerificationEmail({ email: body.email, customerResend: true });
      return response;
    }

    const saltPassword = bcrypt.genSaltSync(10);
    const hashedPassword = bcrypt.hashSync(body.password, saltPassword);
    
    const userPayload = {
      ...body,
      password: hashedPassword,
      isEmailVerified: false
    };

    const newUser = await this.userService.createUser(userPayload as Omit<IUser, '_id'>);
    
    const { verificationLink } = await this.userService.cacheEmailVerificationDetail({ email: newUser.email });

    const userData = {
      _id: newUser._id,
      firstname: newUser.firstname,
      lastname: newUser.lastname,
      email: newUser.email,
      phone: newUser.phone,
      gender: newUser.gender,
      isEmailVerified: newUser.isEmailVerified
    };

    try {
      await EmailService.sendEmailVerification({
        to: newUser.email,
        verificationLink
      });
      logger.info(`Verification email sent to ${newUser.email}`);
    } catch (error) {
      logger.error(`Failed to send verification email to ${newUser.email}:`, error);
    }

    return userData;
  }

  async verifyEmail(email: string, verificationToken: string): Promise<void> {
    const user = await this.userService.getUser({ email });
    if (!user) {
      throw new ResourceNotFoundError({ message: 'User not found', reason: 'Customer not registered' });
    }

    const isTokenValid = await this.userService.isVerificationTokenValid(email, verificationToken);
    if (!isTokenValid) {
      throw new BadRequestError({
        message: 'Verification token has expired',
        data: { status: VerificationTokenStatus.Expired }
      });
    }
    await this.userService.updateUser({ isEmailVerified: true }, { email });

    await this.userService.clearCachedVerificationToken(email);
    await EmailService.welcomeEmail({
      to: user.email,
      name: `${capitalizeFirstLetter(user.firstname)} ${capitalizeFirstLetter(user.lastname)}`
    });
    logger.info(`Welcome email sent to ${user.email}`);
  }

  async resendVerificationEmail(params: { email: string; customerResend?: boolean }): Promise<ResendVerificationEmailResponse> {
    const user = await this.userService.getUser({ email: params.email });
    if (!user) {
      throw new ResourceNotFoundError({ message: 'User not found', reason: 'Customer not registered' });
    } else if (user.isEmailVerified) {
      throw new BadRequestError({ message: `User with email: ${params.email} is already verified`, reason: 'Email already verified' });
    }

    const { verificationLink } = await this.userService.cacheEmailVerificationDetail({
      email: params.email,
      customerResend: !!params.customerResend
    });

    try {
      await EmailService.sendEmailVerification({ to: user.email, verificationLink });
      logger.info(`Verification email sent to ${user.email}`);
    } catch (error) {
      logger.error(`Failed to send verification email to ${user.email}:`, error);
    }

    return {
      email: user.email,
      nextResendDuration: settings.customer_email_verification.resend_limit_lockout_duration
    };
  }

  async loginUser(body: { email: string; password: string }): Promise<LoginResponse> {
    const user = await this.userService.getUser({ email: body.email });
    if (!user) {
      throw new ResourceNotFoundError({ message: 'User not found', reason: 'Customer not registered' });
    }

    const passwordCorrect = await bcrypt.compare(body.password, user.password);
    if (!passwordCorrect) {
      throw new BadRequestError({ message: 'Invalid password or email' });
    }

    const accessToken = generateAccessJwtToken({ id: user._id, email: user.email });
    const refreshToken = generateRefreshJwtToken({ id: user._id });
    await this.userService.cacheRefreshToken({ userId: user._id, refreshToken });

    const { firstname, lastname, email } = user;

    return { firstname, lastname, email, accessToken, refreshToken };
  }

  async refreshToken(data: {
    userId: string;
    refreshToken: string;
  }): Promise<{ id: string; name: string; email: string; accessToken: string; refreshToken: string }> {
    const user = await this.userService.findUserById(data.userId);
    if (!user) {
      throw new ResourceNotFoundError({ message: 'User not found', reason: 'Customer not registered' });
    }

    const isTokenValid = await this.userService.isRefreshTokenValid({ userId: data.userId, refreshToken: data.refreshToken });
    if (!isTokenValid) {
      throw new BadRequestError({ message: 'Invalid refresh token', reason: 'Refresh token is invalid' });
    }

    const refreshToken = generateRefreshJwtToken({ id: user._id });
    const accessToken = generateAccessJwtToken({ id: user._id, email: user.email });
    await this.userService.cacheRefreshToken({ userId: user._id, refreshToken });

    const { _id, firstname, lastname, email } = user;
    const name = `${firstname} ${lastname}`;
    return { id: _id, name, email, accessToken, refreshToken };
  }

  async logout(userId: string): Promise<void> {
    const user = await this.userService.findUserById(userId);
    if (!user) {
      throw new ResourceNotFoundError({ message: 'User not found', reason: 'Customer not registered' });
    }

    await this.userService.clearCachedToken(userId);
  }

  async me(userId: string): Promise<UserProfileData> {
    const user = await this.userService.getUserWithRoleName({ _id: userId });
    if (!user) {
      throw new ResourceNotFoundError({ message: 'User not found', reason: 'Customer not registered' });
    }

    const userData: UserProfileData = {
      id: user._id,
      firstname: user.firstname,
      lastname: user.lastname,
      email: user.email,
      phone: user.phone,
      gender: user.gender,
      isEmailVerified: user.isEmailVerified
    };

    // If user has role information
    if ((user as any).role?.name) {
      userData.role = (user as any).role.name;
    }

    return userData;
  }

  async updateUser(userId: string, body: Partial<Omit<IUser, '_id'>>): Promise<{ modifiedCount: number }> {
    const user = await this.userService.findUserById(userId);
    if (!user) {
      throw new ResourceNotFoundError({ message: 'User not found', reason: 'Customer not registered' });
    }

    const updatedUser = await this.userService.updateUser(body, { _id: userId });
    return updatedUser;
  }

  async changePassword(userId: string, body: { oldPassword: string; newPassword: string; confirmPassword: string }): Promise<void> {
    const user = await this.userService.findUserById(userId);
    if (!user) {
      throw new ResourceNotFoundError({ message: 'User not found', reason: 'Customer not registered' });
    }

    const passwordCorrect = await bcrypt.compare(body.oldPassword, user.password);
    if (!passwordCorrect) {
      throw new BadRequestError({ message: 'Invalid old password', reason: 'Old password is incorrect' });
    }

    if (body.newPassword !== body.confirmPassword) {
      throw new BadRequestError({ message: 'New password and confirm password do not match', reason: 'Password mismatch' });
    }

    if (body.oldPassword === body.newPassword) {
      throw new BadRequestError({ message: 'New password cannot be the same as old password' });
    }
    
    const saltPassword = bcrypt.genSaltSync(10);
    const hashedNewPassword = bcrypt.hashSync(body.newPassword, saltPassword);

    await this.userService.updateUser({ password: hashedNewPassword }, { _id: userId });
  }

  async resetPassword(email: string): Promise<void> {
    const user = await this.userService.getUser({ email });
    if (!user) {
      throw new ResourceNotFoundError({ message: 'User not found', reason: 'Customer not registered' });
    }

    const { resetPasswordLink } = await this.userService.cachePasswordResetDetails(email);

    try {
      await EmailService.sendPasswordResetMail({
        to: user.email,
        code: resetPasswordLink
      });
      logger.info(`Password reset email sent to ${user.email}`);
    } catch (error) {
      logger.error(`Failed to send password reset email to ${user.email}:`, error);
    }
  }
  
  async verifyResetPasswordWithToken(email: string, resetPasswordCode: string, newPassword: string, confirmPassword: string): Promise<void> {
    const user = await this.userService.getUser({ email });
    if (!user) {
      throw new ResourceNotFoundError({ message: 'User not found', reason: 'Customer not registered' });
    }

    const isResetPasswordCodeValid = await this.userService.isPasswordResetTokenValid(email, resetPasswordCode);
    if (!isResetPasswordCodeValid) {
      throw new BadRequestError({
        message: 'Password reset token has expired',
        data: { status: VerificationTokenStatus.Expired }
      });
    }

    if (newPassword !== confirmPassword) {
      throw new BadRequestError({ message: 'New password and confirm password do not match', reason: 'Password mismatch' });
    }

    const saltPassword = bcrypt.genSaltSync(10);
    const hashedNewPassword = bcrypt.hashSync(newPassword, saltPassword);

    await this.userService.updateUser({ password: hashedNewPassword }, { email });
    await this.userService.clearCachedPasswordResetToken(email);
  }
}

export default UserController;
